#  RegExp 对象


## 正向预查

* ` ?= `


## 负向预查

* ` (?<![a-z])\d{7} ` 匹配前面不是小写字母的七位数字
* ` (?<=<(\w+)>).*(?=<\/\1>) ` 不包括前缀和后缀本身
* 如何把 ` xx <aa <bbb> <bbb> aa> yy ` 这样的字符串里，最长的配对的尖括号内的内容捕获出来？




## 正则元字符

| 元字符| 示例 |描述|备注|
| :-|:- |:- |-:|
| . | 除了换行符之外的任意字符 | 包括换行 [.\n] |
| \w | word 文字，字母，数字下划线或汉字 |
| \s | space 空格，任意的空白，空格，包括换行 |
| \d | digit 数字，只匹配数字 |
| \b | 边界符，单词的开始或结束 |
| ^ | 字符串的开始，以 ** 开始 |
| $ | 字符串的结束，以 **结尾 |


## 元字符的反义，全部大写

| 元字符  | 示例 | 描述 | 备注 |
| :-|:- |:- |-:|
| \W | 不是字母，数字，下划线，汉字的字符 | 和小写的完全相反|
| \S | !space, 不是空格，空白符的字符 |
| \D | !digit, 不是数字的字符 |
| \B | !边界符, 不是单词的开头或结尾位置，取值在中间的 |
| \O | 查找 NUL字符 |
| [^x] | 除了 x 以外的任意字符 |
| [^abc] | 除了 abc 这几个字母以外的任意字符 |
| \n | 匹配换行符 |
| \f | 匹配换页符 |
| \r | 匹配回车符 |
| \t | 匹配制表符 |
| \v | 匹配垂直制表符 |
| \xxx |  |
| \xdd |  |
| \uxxxx |  |



## 正则量词

| 量词 | 示例 | 描述 | 备注 |
| :-|:-:|-:|-:|
| + | n+ | 	匹配任何包含至少一个 n 的字符串 | 重复 1次或多次 |
| * | n* | 匹配任何包含零个或多个 n 的字符串 | 重复 0次或多次，.* 匹配任意文本 |
| ? | n?	| 匹配任何包含零个或一个 n 的字符串 | 重复 0次或 1次 |
| \ | \\*  \\?	| 转义字符 | 匹配 . 或者?这样的字符，就要用 转义字符 |
| {n} | n{X}| 	匹配包含 X 个 n 的序列的字符串 | 重复 n次 |
| {n, m} | n{X,Y}| 	匹配包含 X 至 Y 个 n 的序列的字符串 | 重复n到m次 |
| {n,} | n{X,}	| 匹配包含至少 X 个 n 的序列的字符串 | 重复n次或更多次 |
|  | n$	| 匹配任何结尾为 n 的字符串 |
|  | ^n	| 匹配任何开头为 n 的字符串 |
|  | ?=n	| 匹配任何其后紧接指定字符串 n 的字符串 |
|  | ?!n	| 匹配任何其后没有紧接指定字符串 n 的字符串 |



## 正则细节

1. \* 和 + 的区别？

```js
	* 任意长度的字符串

	+  一次或多次

	[0-9] 等价于 \d

	[a-z0-9A-Z_]  等价于 \w

	[&?.]


```



## 正则中的重复

* 分支条件
* 重复的使用场景



### 分支条件

* 用 | 把不同的规则分隔开
* 从左到右地测试每个条件，如果满足了某个分支的话，就不会去再管其它的条件了
* 电话号码正则 ` 0\d{2}-\d{8}|0\d{3}-\d{7} `



## 分组

* 使用 () 进分组，分组的命名 ` (?<groupname>expr) `
	* ` (\d{1,3}\.){3}\d{1,3} `
	* ` (?:expr) ` 匹配 expr，但不捕获匹配的文本，也不给这个分组分配组号

* 将子表达式做成子集，方便对 match 字符串进行划分
* 分组的应用场景



### 贪婪模式

* 尽可能多的匹配

```jsx

	a.*b  (aabab) -> aabab

```


### 懒惰模式

| 量词 | 示例 | 描述 | 备注 |
| :-|:-:|-:|-:|
| *? || 重复任意次| 尽可能少重复 |
| +? || 重复 1次或更多次，| 尽可能少重复 |
| ?? || 重复0次或1次 | 尽可能少重复 |
| {n, m}? || 重复n到m次 | 尽可能少重复 |
| {n,}? || 重复n次以上 | 尽可能少重复 |

* 尽可能少的匹配
* 匹配任意数量的重复，在匹配成功的前提下，使用最少的重复

```jsx
	a.*?b (aabab) -> aab

```






* RegExp window 内置对象
* 让正则表达式 解决问题成为一种习惯
* 正则的应用场景：批量提取，替换有规律的字符串

var cn = /^[\u4e00-\u9fa5]+$/;  中文集合
	cn.test('洛阳')
	cn.test('luoyang')

split
	/s+/ s 空格
	d 数字 0-9 \d
		/^1\d{10}/ 匹配长度大于 10也是 true，加上 $
		var str = /^1\d{10}$/

		var str = /^1[3-9]\d{9}$/ 排除 12开头的

	[] 匹配

	{}

	$ 结束
	^ 开始



	\ 转移符
	+ 一个或多个

	| 或
	$

	\b 单词边界，指 [a-zA-Z_0-9之外的字符]

	\B 飞单词边界

	g 全局匹配
	i 大小写不敏感
	m 多行匹配, 当使用^ $才有效

	.  [^\n\r] 除了换行和回车之外的任意字符
	\d [0-9]  数字
	\D [^0-9] 不是数字

	\s [\t\n\xOB\f\r]  空白字符
	\S [^ \t\n\xOB\f\r] 非空白字符

	\w [a-zA-Z_0-9]  单词字符，所有的字幕
	\W [^a-zA-Z_0-9] 非单词字符

	str = 'abcde'
	str.indexOf('cd') 返回索引
	str.search('cd') 返回的是索引
	str.search(/cd/) 查找


	match() 在父字符串汇总寻找匹配字符串 ，参数是配置字符串

	var str = 'abcccbbbbbbbsdadadbbb'
	str.match(/b+/g)
	str.match('bb')

	只能输入小数点后2位
	/^\d+(\.\d{1,2})?$/.test(value)  // true & false

	this.value.match(/\d+(\.\d{0,2})?$/)||[''])[0]

	1 首先判断必须都是数字 isNaN('230129.123')
	然后 return Math.round(x*100)/100






### () 组，限制多选结构的范围
* () 是为了提取匹配字符串的，表达式中有几个()就有几个相应的匹配字符串
* (abc|bcd|cde),表示这一段是abc、bcd、cde三者之一，顺序也必须一致
* (abc)? 表示这一组要么一起出现，要么不出现，出现那则按顺序出现
* (?:abc)表示找到一样abc的一组，但是不记录，不保存到变量中，否则可以通过x取第几个括号所匹配到的项
```
(aaa)(bbb)(ccc)(?:ddd)(eee) 可以用
	$1 获取(aaa)匹配到的内容，
	$3 获取到了(ccc)匹配到的内容
	$4 获取的是由(eee)

a(?=bbb)
	顺序环视 表示a后面必须紧跟3个连续的b 
	
(?i:xxxx) 不区分大小写

(?s:.*) 跨行匹配，可以匹配回车符
	
(\s*) 表示连续空格的字符串

```


## 分组
1. 解决多个字符串重复
2. 可以在外面获取
	* 格式，任意个字符
	* 获取，正则内部获取，\数字，例如: \1, \2
	* 正则外部获取，$数字，例如: $1, $2
	* 数字是从 1开始的

## 分组的反向引用
* \1 编号，在表达式中
* $ 编号，从1开始计数
  
```jsx
	/(bye)\1/.test('byebye') // true

	'123*456'.replace(/(\d{3})\*(\d{3})/, '$2*$1')


```


## 正则表达式中的特殊字符
* 普通字符
  * 大小写的字母，数字
* 特殊字符（元字符），metacharacters
  * 元字符有特殊的含义
  * 常用元字符: ` () [] {} \ ^ $ | ? * + . `
  * 匹配元字符必须用转移符 \
    * 例如：` \(, \+, \\ `

* () & [] & {} 的区别
  * () 组，用在限制多选结构的范围/分组/捕获文本/环视/特殊模式处理
  * [] 单个匹配，字符集/排除字符集/命名字符集
  * {} 


## 正则字符集
* JS 正则有4类字符集
1. 简单类
2. 范围类
3. 负向类
4. 组合类

### 1 简单类
* 正则的一个字符对应一个，用 [] 括起来，让 [] 这个整体对应一个字符

```jsx
	o[usb]t 匹配
	out, ost, obt
```

### 2 范围类
* 有时匹配的东西太多，而且类型相同，全部输入麻烦，可以在中间加上 - 横线

```jsx
	[a-z], [0-9], [A-Z]
	
	id[0-9] 匹配 id0, id1, id2, id3, 一直到 id9
```

### 3 负向类
* ^ 不包含
* [] 前面加个元字符进行取反，表示不能匹配 [] 里面的字符

```jsx
	[^a]

	o[^0-9]t 匹配 oat, art, 除了数字之外的
	匹配不到 o0t, o3t
```


### 4 组合类
* 用中括号 [] 匹配不同类型的单个字符
* 将几个集合拼接在一起，表示一个组合的集合

```jsx
	[0-9a-zA-Z]

	o[a-zA-Z]t 匹配到 oat, abt, oAt, oOt
```



### [] 单个匹配 字符集
```
[0-3]
	表示找到一个位置上的字符只能是0到3折四个数字，
	与 (abc|bcd|cde) 的作用比较类似
		() 圆括号可以匹配多个连续的字符
		[] 只能匹配单个字符

[^0-3]
	表示找到这个位置上字符只能是除了0到3之外的所有字符

[:digit:] 0-9 
[:alnum] A-Za-z0-9

()本身不匹配任何东西，只是把括号内的内容作为同一个表达式来处理，例如
(ab){1,3}
	表示ab一起连续出现最少1次，最多三次
	如果没有括号的话，ab{1,3},

```



## 正则量词
* ? 出现 0次，或一次
* + 出现一次，或多次
* * 出现 0次，或任意次
* {n} 硬性量词，0次， 或 n次
* {n,} 软性量词，至少出现 n次， + 的升级版
* {n, m} 软性量词，出现 n次，但不超过 m次，中间不能有空格
  
```jsx
	// ? 有没有，0次或1次，问他有没有
	/ab?c/.test('ac')

	// * 0次，或多次
	/ab*c/.test('ac')

	// + 1次或多次
	/ab+c/.test('ac')

	// {3} 0次或 n次
	/ab{3}c/.test('abbc')

	// {2, 6} 出现2次，不能超过6次
	/ab{2,6}c/.test('abc')

	// {3,} 至少出现 3次
	/ab{3,}c/.test('abbbbc')

```



## 正则修饰符
* g 全局匹配， global
* i 忽略大小写
* m 多行匹配
* | 或

* \s+ 贪婪模式，尽可能多的匹配，性能高
* \s 只表示一个空格，匹配次数多，性能相对低

```jsx
	// 中文字符
	var cn = /[\u4e00-\u9fa5]/

	// | 或
	/a|b/
```



## replace()
* 字符串返回值的三种类型
```jsx
	返回数字  indexOf, lastIndexOf, search, charCodeAt
  返回数组  split, match
  返回字符串 charAt, subString, substr, slice, replace

// replace(p1, p2)
参数p1 字符串或正则表达式
	如果是函数，一定要执行，并且有 return返回值，返回值是字符串或 正则

参数p2 字符串或函数
	字符串表示结果，匹配过程中不会执行

	如果一次性匹配，需要些的正则比较复杂，可以吧正则拆分开，一步步替换
```


## exec()


## 分界
* 字符串的边界，就是字符串的 首尾
* 开始位置 ^, /^abc/ ，判断字符串以 abc开始
  * 注意不能紧跟在 [] 左中括号的后面，那就是反向了
* 结束位置 $, /abc$/ ，字符串以 abc结尾
* 单词的分界
  * \b 单词分隔符 [0-9a-zA-Z]
  * \B 非单词分隔符